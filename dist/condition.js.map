{"version":3,"sources":["../src/condition.js"],"names":["ConditionType","And","Or","Not","Condition","attrs","schema","_type","type","_schema","_expressions","expressions","map","o","addEmptyCondition","condition","addEmptyExpression","push","removeCondition","without","ensureEmptyExpression","hasEmpty","expression","field","removeExpression","toJSON"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;AAEO,IAAMA,wCAAgB;AAC3BC,OAAK,KADsB;AAE3BC,MAAI,IAFuB;AAG3BC,OAAK;AAHsB,CAAtB;;IAMMC,S,WAAAA,S;AACX,qBAAYC,KAAZ,EAAmBC,MAAnB,EAA2B;AAAA;;AACzB,SAAKC,KAAL,GAAaF,MAAMG,IAAN,IAAcR,cAAcC,GAAzC;AACA,SAAKQ,OAAL,GAAeH,MAAf;AACA,SAAKI,YAAL,GAAoB,EAApB;;AAEA,QAAIL,MAAMM,WAAV,EAAuB;AACrB,WAAKD,YAAL,GAAoBL,MAAMM,WAAN,CAAkBC,GAAlB,CAAsB,UAACC,CAAD,EAAO;AAC/C,YAAIA,EAAEF,WAAN,EAAmB;AACjB,iBAAO,IAAIP,SAAJ,CAAcS,CAAd,EAAiBP,MAAjB,CAAP;AACD;;AAED,eAAO,2BAAeO,CAAf,EAAkBP,MAAlB,CAAP;AACD,OANmB,CAApB;AAOD;AACF;;sBAcDQ,iB,gCAAoB;AAClB,QAAMC,YAAY,IAAIX,SAAJ,CAAc,EAAd,EAAkB,KAAKK,OAAvB,CAAlB;;AAEAM,cAAUC,kBAAV;;AAEA,SAAKN,YAAL,CAAkBO,IAAlB,CAAuBF,SAAvB;AACD,G;;sBAEDG,e,4BAAgBH,S,EAAW;AACzB,SAAKL,YAAL,GAAoB,iBAAES,OAAF,CAAU,KAAKT,YAAf,EAA6BK,SAA7B,CAApB;AACD,G;;sBAEDK,qB,oCAAwB;AACtB,QAAIC,WAAW,KAAf;;AAEA,yBAAyB,KAAKX,YAA9B,kHAA4C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,UAAjCY,UAAiC;;AAC1C,UAAI,CAACA,WAAWC,KAAhB,EAAuB;AACrBF,mBAAW,IAAX;AACA;AACD;AACF;;AAED,QAAI,CAACA,QAAL,EAAe;AACb,WAAKL,kBAAL;AACD;AACF,G;;sBAEDA,kB,iCAAqB;AACnB,SAAKN,YAAL,CAAkBO,IAAlB,CAAuB,2BAAe,EAAf,EAAmB,KAAKR,OAAxB,CAAvB;AACD,G;;sBAEDe,gB,6BAAiBF,U,EAAY;AAC3B,SAAKZ,YAAL,GAAoB,iBAAES,OAAF,CAAU,KAAKT,YAAf,EAA6BY,UAA7B,CAApB;AACD,G;;sBAEDG,M,qBAAS;AACP,WAAO;AACLjB,YAAM,KAAKA,IADN;AAELG,mBAAa,KAAKA,WAAL,GAAmB,KAAKA,WAAL,CAAiBC,GAAjB,CAAqB;AAAA,eAAKC,EAAEY,MAAF,EAAL;AAAA,OAArB,CAAnB,GAA2D;AAFnE,KAAP;AAID,G;;;;wBApDU;AACT,aAAO,KAAKlB,KAAZ;AACD,K;sBAEQC,I,EAAM;AACb,WAAKD,KAAL,GAAaC,IAAb;AACD;;;wBAEiB;AAChB,aAAO,KAAKE,YAAZ;AACD","file":"condition.js","sourcesContent":["import { Expression } from './expression';\nimport _ from 'lodash';\n\nexport const ConditionType = {\n  And: 'and',\n  Or: 'or',\n  Not: 'not'\n};\n\nexport class Condition {\n  constructor(attrs, schema) {\n    this._type = attrs.type || ConditionType.And;\n    this._schema = schema;\n    this._expressions = [];\n\n    if (attrs.expressions) {\n      this._expressions = attrs.expressions.map((o) => {\n        if (o.expressions) {\n          return new Condition(o, schema);\n        }\n\n        return new Expression(o, schema);\n      });\n    }\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n  }\n\n  get expressions() {\n    return this._expressions;\n  }\n\n  addEmptyCondition() {\n    const condition = new Condition({}, this._schema);\n\n    condition.addEmptyExpression();\n\n    this._expressions.push(condition);\n  }\n\n  removeCondition(condition) {\n    this._expressions = _.without(this._expressions, condition);\n  }\n\n  ensureEmptyExpression() {\n    let hasEmpty = false;\n\n    for (const expression of this._expressions) {\n      if (!expression.field) {\n        hasEmpty = true;\n        break;\n      }\n    }\n\n    if (!hasEmpty) {\n      this.addEmptyExpression();\n    }\n  }\n\n  addEmptyExpression() {\n    this._expressions.push(new Expression({}, this._schema));\n  }\n\n  removeExpression(expression) {\n    this._expressions = _.without(this._expressions, expression);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      expressions: this.expressions ? this.expressions.map(o => o.toJSON()) : null\n    };\n  }\n}\n"]}