{"version":3,"sources":["../src/condition.js"],"names":["ConditionType","And","Or","Not","Condition","attrs","schema","_type","type","_schema","_expressions","expressions","filter","o","map","ensureEmptyExpression","addEmptyCondition","condition","addEmptyExpression","push","removeCondition","without","hasEmpty","expression","field","removeExpression","toJSON","length","toHumanDescription","topLevel","descriptions","desc","join","toUpperCase","apply","allExpressions"],"mappings":"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","file":"condition.js","sourcesContent":["import { Expression } from './expression';\nimport _ from 'lodash';\n\nexport const ConditionType = {\n  And: 'and',\n  Or: 'or',\n  Not: 'not'\n};\n\nexport class Condition {\n  constructor(attrs, schema) {\n    attrs = attrs || {};\n\n    this._type = attrs.type || ConditionType.And;\n    this._schema = schema;\n    this._expressions = [];\n\n    if (attrs.expressions) {\n      this._expressions = attrs.expressions.filter(o => o).map((o) => {\n        if (o.expressions) {\n          return new Condition(o, schema);\n        }\n\n        return new Expression(o, schema);\n      });\n    }\n\n    this.ensureEmptyExpression();\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n  }\n\n  get expressions() {\n    return this._expressions;\n  }\n\n  addEmptyCondition() {\n    const condition = new Condition({}, this._schema);\n\n    condition.addEmptyExpression();\n\n    this._expressions.push(condition);\n  }\n\n  removeCondition(condition) {\n    this._expressions = _.without(this._expressions, condition);\n  }\n\n  ensureEmptyExpression() {\n    let hasEmpty = false;\n\n    for (const expression of this._expressions) {\n      if (!expression.field) {\n        hasEmpty = true;\n        break;\n      }\n    }\n\n    if (!hasEmpty) {\n      this.addEmptyExpression();\n    }\n  }\n\n  addEmptyExpression() {\n    this._expressions.push(new Expression({}, this._schema));\n  }\n\n  removeExpression(expression) {\n    this._expressions = _.without(this._expressions, expression);\n  }\n\n  toJSON() {\n    const expressions = this.expressions.map(o => o.toJSON()).filter(o => o);\n\n    if (!expressions.length) {\n      return null;\n    }\n\n    return {\n      type: this.type,\n      expressions: expressions\n    };\n  }\n\n  get allExpressions() {\n    const expressions = [];\n\n    for (const o of this.expressions) {\n      if (o.expressions) {\n        expressions.push.apply(expressions, o.allExpressions);\n      } else {\n        expressions.push(o);\n      }\n    }\n\n    return expressions;\n  }\n\n  toHumanDescription(topLevel = false) {\n    if (this.expressions.length === 0) {\n      return null;\n    }\n\n    const descriptions = [];\n\n    for (const expression of this.expressions) {\n      const desc = expression.toHumanDescription();\n\n      if (desc) {\n        descriptions.push(desc);\n      }\n    }\n\n    if (descriptions.length === 0) {\n      return null;\n    }\n\n    if (this.type === 'not') {\n      return '(NOT ' + descriptions.join(' AND ') + ')';\n    }\n\n    return '(' + descriptions.join(' ' + this.type.toUpperCase() + ' ') + ')';\n  }\n}\n"]}