{"version":3,"sources":["../src/condition.js"],"names":["ConditionType","And","Or","Not","Condition","attrs","schema","_type","type","_schema","_expressions","expressions","map","o","ensureEmptyExpression","addEmptyCondition","condition","addEmptyExpression","push","removeCondition","without","hasEmpty","expression","field","removeExpression","toJSON","toHumanDescription","topLevel","length","descriptions","desc","join","toUpperCase"],"mappings":"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","file":"condition.js","sourcesContent":["import { Expression } from './expression';\nimport _ from 'lodash';\n\nexport const ConditionType = {\n  And: 'and',\n  Or: 'or',\n  Not: 'not'\n};\n\nexport class Condition {\n  constructor(attrs, schema) {\n    attrs = attrs || {};\n\n    this._type = attrs.type || ConditionType.And;\n    this._schema = schema;\n    this._expressions = [];\n\n    if (attrs.expressions) {\n      this._expressions = attrs.expressions.map((o) => {\n        if (o.expressions) {\n          return new Condition(o, schema);\n        }\n\n        return new Expression(o, schema);\n      });\n    }\n\n    this.ensureEmptyExpression();\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n  }\n\n  get expressions() {\n    return this._expressions;\n  }\n\n  addEmptyCondition() {\n    const condition = new Condition({}, this._schema);\n\n    condition.addEmptyExpression();\n\n    this._expressions.push(condition);\n  }\n\n  removeCondition(condition) {\n    this._expressions = _.without(this._expressions, condition);\n  }\n\n  ensureEmptyExpression() {\n    let hasEmpty = false;\n\n    for (const expression of this._expressions) {\n      if (!expression.field) {\n        hasEmpty = true;\n        break;\n      }\n    }\n\n    if (!hasEmpty) {\n      this.addEmptyExpression();\n    }\n  }\n\n  addEmptyExpression() {\n    this._expressions.push(new Expression({}, this._schema));\n  }\n\n  removeExpression(expression) {\n    this._expressions = _.without(this._expressions, expression);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      expressions: this.expressions ? this.expressions.map(o => o.toJSON()) : null\n    };\n  }\n\n  toHumanDescription(topLevel = false) {\n    if (this.expressions.length === 0) {\n      return null;\n    }\n\n    const descriptions = [];\n\n    for (const expression of this.expressions) {\n      const desc = expression.toHumanDescription();\n\n      if (desc) {\n        descriptions.push(desc);\n      }\n    }\n\n    if (descriptions.length === 0) {\n      return null;\n    }\n\n    if (this.type === 'not') {\n      return '(NOT ' + descriptions.join(' AND ') + ')';\n    }\n\n    return '(' + descriptions.join(' ' + this.type.toUpperCase() + ' ') + ')';\n  }\n}\n"]}