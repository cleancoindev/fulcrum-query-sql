{"version":3,"sources":["../src/aggregate.js"],"names":["availableAggregatesForColumn","AggregateType","Sum","name","label","Average","Median","Min","Max","StdDev","Histogram","Empty","count","NotEmpty","Unique","PercentEmpty","PercentNotEmpty","PercentUnique","AggregatesByValue","Object","keys","key","TEXTUAL_AGGREGATES","NUMERIC_AGGREGATES","DATE_AGGREGATES","column","aggregates","element","isRepeatableElement","isNumber","push","apply","isArray","isDate"],"mappings":";;;QA4FgBA,4B,GAAAA,4B;AA5FT,IAAMC,wCAAgB;AAC3BC,OAAK;AACHC,UAAM,KADH;AAEHC,WAAO;AAFJ,GADsB;AAK3BC,WAAS;AACPF,UAAM,SADC;AAEPC,WAAO;AAFA,GALkB;AAS3BE,UAAQ;AACNH,UAAM,QADA;AAENC,WAAO;AAFD,GATmB;AAa3BG,OAAK;AACHJ,UAAM,KADH;AAEHC,WAAO;AAFJ,GAbsB;AAiB3BI,OAAK;AACHL,UAAM,KADH;AAEHC,WAAO;AAFJ,GAjBsB;AAqB3BK,UAAQ;AACNN,UAAM,QADA;AAENC,WAAO;AAFD,GArBmB;AAyB3BM,aAAW;AACTP,UAAM,WADG;AAETC,WAAO;AAFE,GAzBgB;AA6B3BO,SAAO;AACLR,UAAM,OADD;AAELC,WAAO,aAFF;AAGLQ,WAAO;AAHF,GA7BoB;AAkC3BC,YAAU;AACRV,UAAM,WADE;AAERC,WAAO,iBAFC;AAGRQ,WAAO;AAHC,GAlCiB;AAuC3BE,UAAQ;AACNX,UAAM,QADA;AAENC,WAAO,qBAFD;AAGNQ,WAAO;AAHD,GAvCmB;AA4C3BG,gBAAc;AACZZ,UAAM,eADM;AAEZC,WAAO;AAFK,GA5Ca;AAgD3BY,mBAAiB;AACfb,UAAM,mBADS;AAEfC,WAAO;AAFQ,GAhDU;AAoD3Ba,iBAAe;AACbd,UAAM,gBADO;AAEbC,WAAO;AAFM;AApDY,CAAtB;;AA0DA,IAAMc,gDAAoB,EAA1B;;AAEP,qBAAkBC,OAAOC,IAAP,CAAYnB,aAAZ,CAAlB,kHAA8C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,MAAnCoB,GAAmC;;AAC5CH,oBAAkBjB,cAAcoB,GAAd,EAAmBlB,IAArC,IAA6CF,cAAcoB,GAAd,CAA7C;AACD;;AAED,IAAMC,qBAAqB,CACzBrB,cAAcU,KADW,EAEzBV,cAAcY,QAFW,EAGzBZ,cAAca,MAHW,CAA3B;;AAMA,IAAMS,qBAAqB,CACzBtB,cAAcC,GADW,EAEzBD,cAAcI,OAFW;AAGzB;AACAJ,cAAcM,GAJW,EAKzBN,cAAcO,GALW,EAMzBP,cAAcQ,MANW,EAOzBR,cAAcS,SAPW,EAQzBT,cAAcU,KARW,EASzBV,cAAcY,QATW,EAUzBZ,cAAca,MAVW,CAA3B;;AAaA,IAAMU,kBAAkB,CACtBvB,cAAcM,GADQ,EAEtBN,cAAcO,GAFQ,EAGtBP,cAAcS,SAHQ,EAItBT,cAAcU,KAJQ,EAKtBV,cAAcY,QALQ,EAMtBZ,cAAca,MANQ,CAAxB;;AASO,SAASd,4BAAT,CAAsCyB,MAAtC,EAA8C;AACnD,MAAMC,aAAa,EAAnB;;AAEA,MAAID,UAAU,IAAd,EAAoB;AAClB,WAAOC,UAAP;AACD;;AAED;AACA;AACA;AACA;AACA,MAAID,OAAOE,OAAP,IAAkBF,OAAOE,OAAP,CAAeC,mBAArC,EAA0D;AACxD,WAAOF,UAAP;AACD;;AAED,MAAID,OAAOI,QAAX,EAAqB;AACnBH,eAAWI,IAAX,CAAgBC,KAAhB,CAAsBL,UAAtB,EAAkCH,kBAAlC;AACD,GAFD,MAEO,IAAIE,OAAOO,OAAX,EAAoB;AACzB;AACD,GAFM,MAEA,IAAIP,OAAOQ,MAAX,EAAmB;AACxBP,eAAWI,IAAX,CAAgBC,KAAhB,CAAsBL,UAAtB,EAAkCF,eAAlC;AACD,GAFM,MAEA;AACLE,eAAWI,IAAX,CAAgBC,KAAhB,CAAsBL,UAAtB,EAAkCJ,kBAAlC;AACD;;AAED,SAAOI,UAAP;AACD;;QAEQJ,kB,GAAAA,kB;QACAC,kB,GAAAA,kB;QACAC,e,GAAAA,e","file":"aggregate.js","sourcesContent":["export const AggregateType = {\n  Sum: {\n    name: 'sum',\n    label: 'Sum'\n  },\n  Average: {\n    name: 'average',\n    label: 'Average'\n  },\n  Median: {\n    name: 'median',\n    label: 'Median'\n  },\n  Min: {\n    name: 'min',\n    label: 'Min'\n  },\n  Max: {\n    name: 'max',\n    label: 'Max'\n  },\n  StdDev: {\n    name: 'stddev',\n    label: 'Standard Deviation'\n  },\n  Histogram: {\n    name: 'histogram',\n    label: 'Histogram'\n  },\n  Empty: {\n    name: 'empty',\n    label: 'Count Blank',\n    count: true\n  },\n  NotEmpty: {\n    name: 'not_empty',\n    label: 'Count Not Blank',\n    count: true\n  },\n  Unique: {\n    name: 'unique',\n    label: 'Count Unique Values',\n    count: true\n  },\n  PercentEmpty: {\n    name: 'percent_empty',\n    label: '% Blank'\n  },\n  PercentNotEmpty: {\n    name: 'percent_not_empty',\n    label: '% Not Blank'\n  },\n  PercentUnique: {\n    name: 'percent_unique',\n    label: '% Unique'\n  }\n};\n\nexport const AggregatesByValue = {};\n\nfor (const key of Object.keys(AggregateType)) {\n  AggregatesByValue[AggregateType[key].name] = AggregateType[key];\n}\n\nconst TEXTUAL_AGGREGATES = [\n  AggregateType.Empty,\n  AggregateType.NotEmpty,\n  AggregateType.Unique\n];\n\nconst NUMERIC_AGGREGATES = [\n  AggregateType.Sum,\n  AggregateType.Average,\n  // AggregateType.Median,\n  AggregateType.Min,\n  AggregateType.Max,\n  AggregateType.StdDev,\n  AggregateType.Histogram,\n  AggregateType.Empty,\n  AggregateType.NotEmpty,\n  AggregateType.Unique\n];\n\nconst DATE_AGGREGATES = [\n  AggregateType.Min,\n  AggregateType.Max,\n  AggregateType.Histogram,\n  AggregateType.Empty,\n  AggregateType.NotEmpty,\n  AggregateType.Unique\n];\n\nexport function availableAggregatesForColumn(column) {\n  const aggregates = [];\n\n  if (column == null) {\n    return aggregates;\n  }\n\n  // Repeatable columns don't have a physical column to enable aggregates\n  // this column is the \"4 items\" value, which requires the in-memory record.\n  // Until we add an underlying db column for the item count, we can't do any\n  // aggregates on the repeatable itself.\n  if (column.element && column.element.isRepeatableElement) {\n    return aggregates;\n  }\n\n  if (column.isNumber) {\n    aggregates.push.apply(aggregates, NUMERIC_AGGREGATES);\n  } else if (column.isArray) {\n    // aggregates.push.apply(operators, ARRAY_OPERATORS);\n  } else if (column.isDate) {\n    aggregates.push.apply(aggregates, DATE_AGGREGATES);\n  } else {\n    aggregates.push.apply(aggregates, TEXTUAL_AGGREGATES);\n  }\n\n  return aggregates;\n}\n\nexport { TEXTUAL_AGGREGATES };\nexport { NUMERIC_AGGREGATES };\nexport { DATE_AGGREGATES };\n"]}